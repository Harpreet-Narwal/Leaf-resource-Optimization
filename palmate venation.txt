Algorithm:

Start

1)Initialize the ready queue to be empty.

2)Loop until all processes have completed:
a. Check the arrival time of all processes.
b. If a process has arrived, add it to the ready queue.
c. If the CPU is idle and there are processes in the ready queue:
i. Sort the ready queue by priority, with the highest priority process at the front.
ii. Remove the highest priority process from the front of the ready queue and execute it.
iii.Initialize the ready queue to be empty for the veins in the midrib.
iv. Loop until all processes have completed:
	a. Check the arrival time of all processes(veins).
	b. If a process has arrived, add it to the ready queue.
	c. If the CPU is idle and there are processes in the ready queue:
		i. Sort the ready queue by priority, with the highest priority process at the front.
		ii. Remove the highest priority process from the front of the ready queue and execute it.
		iii. If a process with higher priority than the currently executing process arrives, preempt the CPU and add the currently executing process back to the ready queue.
		iv. If the currently executing process finishes executing, mark it as complete and remove it from the system.
	d. If the CPU is not idle and a higher-priority process arrives, preempt the CPU and add the currently executing process back to the ready queue.

3)Calculate and output the average waiting time, turnaround time, and response time for all processes.

END.

	


pseudocode:


# Palmate venation: 1) starting point and midrib

# Initialize ready queue to be empty
ready_queue1=[]     #for midribs
ready_queue2=[]     #for veins

# Loop until all processes have completed
while not all_process_complete:

    # Check arrival time of all processes (midribs)
    for process in processes:

        # Add process to ready queue if it has arrived and is not already in the queue
        if process.arrival_time <= current_time and process not in ready_queue:
            ready_queue1.append(process)



        
    # If CPU is idle and there are processes in the ready queue
    if not current_process and ready_queue1:

        # Sort ready queue by priority (highest priority at front)
        ready_queue1.sort(key=lambda x: x.priority, reverse=True)

        # Remove highest priority process from front of ready queue and execute it
        current_process = ready_queue1.pop(0)


# 2) veins diverging from midribs:
        # Check arrival time of all processes (veins)
        for process in processes:

            # Add process to ready queue if it has arrived and is not already in the queue
            if process.arrival_time <= current_time and process not in ready_queue:
                ready_queue2.append(process)

        # If CPU is idle and there are processes in the ready queue
        if not current_process and ready_queue2:

            # Sort ready queue by priority (highest priority at front)
            ready_queue2.sort(key=lambda x: x.priority, reverse=True)

            # Remove highest priority process from front of ready queue and execute it
            current_process = ready_queue2.pop(0)

        # If CPU is not idle and a higher-priority process arrives
        elif current_process and ready_queue2 and ready_queue2[0].priority > current_process.priority:

            # Add currently executing process back to ready queue
            ready_queue2.append(current_process)

            # Sort ready queue by priority (highest priority at front)
            ready_queue2.sort(key=lambda x: x.priority, reverse=True)

            # Remove highest priority process from front of ready queue and execute it
            current_process = ready_queue2.pop(0)
        


